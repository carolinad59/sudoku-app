<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sudoku</title>
<style>
    body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; }
    h1 { margin-bottom: 10px; }
    #controls { margin-bottom: 10px; }
    button { margin-right: 5px; padding: 5px 10px; }
    button.active { background-color: #4CAF50; color: white; }
    #info { margin-bottom: 10px; }
    #sudoku-grid { display: grid; grid-template-columns: repeat(9, 40px); grid-template-rows: repeat(9, 40px); gap: 0; }
    .cell { border: 1px solid #999; position: relative; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; }
    .border-top { border-top: 3px solid black; }
    .border-bottom { border-bottom: 3px solid black; }
    .border-left { border-left: 3px solid black; }
    .border-right { border-right: 3px solid black; }
    input { width: 100%; height: 100%; text-align: center; font-size: 18px; }
    .notes { position: absolute; top: 0; left: 0; font-size: 10px; display: flex; flex-wrap: wrap; width: 100%; height: 100%; padding: 2px; box-sizing: border-box; pointer-events: none; color: #555; }
</style>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#4CAF50">
<script>
  // registrar service worker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./service-worker.js')
      .then(() => console.log('Service Worker registrado'))
      .catch(err => console.log('Error Service Worker:', err));
  }
</script>

</head>
<body>

<h1>Sudoku</h1>

<div id="controls">
    <button id="new-game">Nuevo Sudoku</button>
    <button id="restart-game">Reiniciar Sudoku</button>
    <button id="notes-btn">Notas</button>
</div>

<div id="info">
    <span id="timer">Tiempo: 00:00</span> |
    Errores: <span id="error-count">0</span>
</div>

<div id="sudoku-grid"></div>

<script>
/* ------------------------------
   Todo tu código JS optimizado
------------------------------ */
let currentPuzzle = [];
let originalPuzzle = [];
let currentLevel = "Fácil";
let notesMode = false;
let errorCount = 0;
let errorMap = [];
let timer;
let seconds = 0;

function createEmptyBoard() {
    return Array.from({ length: 9 }, () => Array(9).fill(0));
}

function isValid(board, row, col, num) {
    for (let i = 0; i < 9; i++) {
        if (board[row][i] === num || board[i][col] === num) return false;
    }
    let boxRow = Math.floor(row / 3) * 3;
    let boxCol = Math.floor(col / 3) * 3;
    for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 3; c++) {
            if (board[boxRow + r][boxCol + c] === num) return false;
        }
    }
    return true;
}

function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function generateFullSudoku() {
    let board = createEmptyBoard();
    let nums = [1,2,3,4,5,6,7,8,9];
    shuffleArray(nums);

    function solveRandom(board) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === 0) {
                    shuffleArray(nums);
                    for (let n = 0; n < 9; n++) {
                        let num = nums[n];
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solveRandom(board)) return true;
                            board[row][col] = 0;
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    solveRandom(board);
    return board;
}

function removeNumbersSmart(board, level) {
    let cellsToRemove;
    switch(level) {
        case "Fácil": cellsToRemove = 30; break;
        case "Medio": cellsToRemove = 40; break;
        case "Difícil": cellsToRemove = 50; break;
        case "Imposible": cellsToRemove = 60; break;
        default: cellsToRemove = 40;
    }
    let newBoard = board.map(row => row.slice());
    let positions = [];
    for (let i = 0; i < 9; i++) for (let j = 0; j < 9; j++) positions.push([i,j]);
    shuffleArray(positions);

    let removed = 0;
    for (let [row, col] of positions) {
        if (removed >= cellsToRemove) break;
        let rowCount = newBoard[row].filter(n => n!==0).length;
        let colCount = newBoard.map(r => r[col]).filter(n => n!==0).length;
        let boxRow = Math.floor(row/3)*3;
        let boxCol = Math.floor(col/3)*3;
        let boxCount=0;
        for (let r=0;r<3;r++) for(let c=0;c<3;c++) if(newBoard[boxRow+r][boxCol+c]!==0) boxCount++;
        if(rowCount>3 && colCount>3 && boxCount>3){
            newBoard[row][col]=0;
            removed++;
        }
    }
    return newBoard;
}

function checkCell(board,row,col,value){
    value=parseInt(value);
    if(!value) return true;
    for(let i=0;i<9;i++){
        if(i!==col && board[row][i]===value) return false;
        if(i!==row && board[i][col]===value) return false;
    }
    let boxRow = Math.floor(row/3)*3;
    let boxCol = Math.floor(col/3)*3;
    for(let r=0;r<3;r++) for(let c=0;c<3;c++){
        let rr=boxRow+r, cc=boxCol+c;
        if((rr!==row || cc!==col) && board[rr][cc]===value) return false;
    }
    return true;
}

function displaySudoku(board){
    const grid = document.getElementById("sudoku-grid");
    grid.innerHTML="";
    errorMap = Array.from({length:9},()=>Array(9).fill(false));

    for(let i=0;i<9;i++){
        for(let j=0;j<9;j++){
            let cell=document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.row=i; cell.dataset.col=j;
            if(i%3===0) cell.classList.add("border-top");
            if(i===8) cell.classList.add("border-bottom");
            if(j%3===0) cell.classList.add("border-left");
            if(j===8) cell.classList.add("border-right");

            if(board[i][j]!==0){
                cell.textContent=board[i][j];
            } else {
                let input=document.createElement("input");
                input.setAttribute("type","text"); input.setAttribute("maxlength","1"); input.style.boxSizing="border-box";
                let notesDiv=document.createElement("div"); notesDiv.classList.add("notes"); cell.appendChild(notesDiv);

                input.addEventListener("input",function(){
                    this.value=this.value.replace(/[^1-9]/g,"");
                    let val=this.value?parseInt(this.value):0;

                    if(notesMode){
                        if(val>0){
                            let notes=new Set(notesDiv.textContent.split("").map(Number));
                            if(notes.has(val)) notes.delete(val);
                            else notes.add(val);
                            notesDiv.textContent=Array.from(notes).sort().join("");
                        }
                        this.value="";
                    } else {
                        board[i][j]=val;
                        notesDiv.textContent="";
                        if(!checkCell(board,i,j,val)){
                            if(!errorMap[i][j]){ errorCount++; document.getElementById("error-count").textContent=errorCount; errorMap[i][j]=true; }
                            this.style.backgroundColor="#ff4d4d";
                        } else { this.style.backgroundColor="white"; errorMap[i][j]=false; }
                    }
                });
                cell.appendChild(input);
            }
            grid.appendChild(cell);
        }
    }
}

function newSudoku(){
    errorCount=0; document.getElementById("error-count").textContent=errorCount;
    currentLevel=document.getElementById("difficulty")?.value || "Fácil";
    const fullSudoku=generateFullSudoku();
    currentPuzzle=removeNumbersSmart(fullSudoku,currentLevel);
    originalPuzzle=currentPuzzle.map(r=>r.slice());
    notesMode=false;
    document.getElementById("notes-btn")?.classList.remove("active");
    displaySudoku(currentPuzzle);
    startTimer();
}

function restartSudoku(){
    errorCount=0; document.getElementById("error-count").textContent=errorCount;
    currentPuzzle=originalPuzzle.map(r=>r.slice());
    displaySudoku(currentPuzzle);
    startTimer();
}

document.getElementById("new-game")?.addEventListener("click",newSudoku);
document.getElementById("restart-game")?.addEventListener("click",restartSudoku);
document.getElementById("notes-btn")?.addEventListener("click",function(){ notesMode=!notesMode; this.classList.toggle("active"); });

function startTimer(){ clearInterval(timer); seconds=0; updateTimerDisplay();
    timer=setInterval(()=>{seconds++; updateTimerDisplay();},1000);
}

function updateTimerDisplay(){ 
    const min=String(Math.floor(seconds/60)).padStart(2,"0");
    const sec=String(seconds%60).padStart(2,"0");
    document.getElementById("timer").textContent=`Tiempo: ${min}:${sec}`;
}

newSudoku();
</script>

</body>
</html>
